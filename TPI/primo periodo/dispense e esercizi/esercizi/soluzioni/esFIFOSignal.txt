Capitolo 3: Esercizi Aggiuntivi

3.1 Esercizi sulle FIFO 

6. Server Persistente con Multipli Client (Invio di Identificatore)

Scrivere `server.c` e `client.c` per implementare un server persistente che gestisce richieste da più client.

 Il Server crea una FIFO nota chiamata `"/tmp/richieste_fifo"` con permessi $0666$[cite: 110].
 Il Server entra in un ciclo infinito di lettura, bloccandosi in attesa di dati.
 Il Client si connette, ottiene il proprio PID (`getpid()`) e lo invia al server, seguito da una stringa di richiesta (es. "DAMMI L'ORA").
 Il Server legge i dati, stampa un messaggio come "Richiesta da PID [X]: [STRINGA]" e continua il suo ciclo.
 Il Server deve implementare un meccanismo di terminazione: se riceve la stringa "QUIT" come messaggio, chiude la FIFO e la rimuove con `unlink()`[cite: 46, 48].
 Istruzioni per l'alunno: Eseguire il Server e poi lanciare più istanze del Client in terminali separati.

7. Scrittura Non Bloccante e Gestione dell'Errore `ENXIO`

Modificare il programma `produttore.c` dell'Esercizio 1 per approfondire il comportamento non bloccante in scrittura.

 Il Produttore tenta di aprire la FIFO con il flag: `O_WRONLY | O_NONBLOCK`.
 Cosa succede se si tenta di aprire la FIFO in sola scrittura (`O_WRONLY`) con `O_NONBLOCK` prima che il Consumatore l'abbia aperta in lettura[cite: 39, 41]? (Si aspetta o restituisce errore? Qual è il codice di errore?).
 Implementare un ciclo nel Produttore in cui:
     Tenta l'apertura non bloccante.
     Se `open()` fallisce con l'errore `ENXIO` (che indica l'assenza di un lettore), il Produttore stampa un messaggio di attesa (es. "Nessun lettore, riprovo...") e `sleep(1)` per 1 secondo.
     Il ciclo deve continuare fino a quando l'apertura ha successo, dopodiché il Produttore invia le 10 stringhe come nell'Esercizio 1.



 3.2 Esercizi sui Segnali (Continuazione)

6. Terminazione Controllata (`SIGTERM`) e Pulizia Risorse

Scrivere un programma C che dimostri la gestione di una terminazione pulita (graceful shutdown) per rilasciare risorse.

 Il programma principale simula l'allocazione di una risorsa, ad esempio: `FILE log_file = fopen("/tmp/app.log", "w");`
 Impostare un handler per il segnale `SIGTERM` (il segnale standard inviato da `kill` per la terminazione).
 L'handler deve:
     Stampare il messaggio: "Ricevuto SIGTERM. Rilascio le risorse prima di uscire."
     Eseguire l'operazione di pulizia: `fclose(log_file);`
     Stampare "Risorse rilasciate. Termino." e chiamare `exit(0)`.
 Il processo principale entra in un ciclo infinito con una breve `sleep(1)` e stampa il proprio stato (es. "Lavorando...").
 Istruzioni per l'alunno: Eseguire il programma, trovare il suo PID (`getpid()`) e inviare il segnale dalla shell usando `kill -SIGTERM [PID]`. Verificare che l'handler venga eseguito e che il processo termini.

7. Segnale di Allarme a Tempo (`SIGALRM` e `alarm()`)

Scrivere un programma che utilizzi un timer asincrono per auto-segnalarsi.

 Il programma deve impostare un handler per il segnale `SIGALRM`.
 L'handler deve stampare il messaggio "Tempo scaduto! L'allarme è scattato." e poi terminare il processo con `exit(0)`.
 Il programma principale deve chiamare `alarm(8)` per inviare a sé stesso un segnale `SIGALRM` dopo 8 secondi.
 Il processo principale deve quindi entrare in uno stato di attesa del segnale usando la system call `pause()`.
 Domanda Aggiuntiva: Cosa succede se il programma non chiama `pause()` e invece entra in un ciclo infinito senza pause?
 Domanda Aggiuntiva: Cosa succederebbe se l'utente premesse `CTRL+C` (`SIGINT`) prima dello scadere degli 8 secondi? Modificare il programma per ignorare il segnale `SIGINT`per assicurarsi che l'attesa si concluda solo con `SIGALRM`.

